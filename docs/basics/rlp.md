---
title: RLP 编码
slug: /rlp
---
### Reference

- [Ethereum Wiki](https://github.com/ethereum/wiki/wiki/RLP)

### RLP (Recursive Length Prefix)

是一种编码算法，可以有效针对嵌套数据结构（比如结构体类型数据）进行编码/解码、序列化/反序列化。RLP编码后的数据第1个字节指引如何获得编码长度，并采取递归方式处理嵌套结构，“递归长度编码” (Recursive Length Prefix)，由此得名。

编码对象：字符串（String）/字节数组（Bytes）、列表（List），字符串本质上是字节数组，可统一对待。

字符串：空串"" => 长度为0的Bytes||、"foo bar zee" => |'f'|'o'|'o'|' '|'b'|'a'|'r'|' '|'z'|'e'|'e'|

字节数组：|0xA5|0x16|0x3C|0x78|0xF8|

列表：集合的同义词，其可包含字符串/字节数组，也可嵌套包含子列表，例如：

空表[ ]、[ "foo bar zee", [ [ ] ], |0xA5|0x16|0x3C|0x78|0xF8|, ["hello", "world"] ]

列表编码长度：内部包含或嵌套包含的各个元素编码后的长度之和（深度优先，递归求和），例如：

[ [ "hi", "foo", [ ] ] ]编码后长度为10 =>
|0xC9|0xC8|0x82|'h'|'i'|0x83|'f'|'o'|'o'|0xC0|

[ "hi", "foo", [ ] ]编码后长度为9 =>
|0xC8|0x82|'h'|'i'|0x83|'f'|'o'|'o'|0xC0|

"hi", "foo", [ ]编码后长度分别为3, 4, 1 =>
|0x82|'h'|'i'|, |0x83|'f'|'o'|'o'|, |0xC0|

在探索编码规则之前，先研究「对编码后的数据第1个字节的解码规则」，会更容易理解一些：

0x00 ~ 0x7F  => 单字节数据0x00 ~ 0x7F，长度为1

0x80 => 空串""，或整数0，长度为0

0x81 ~ 0xB7 => 其后为长度为L的Bytes ，减去0x80可得出值L（1～55）

0xB8 ~ 0xBF => 其后为长度值L（56～(2^64)-1），减去0xB7可得出L自身的长度（1~8），其后为长度为L的Bytes

0xC0 => 表示空表[ ]，长度为0

0xC1 ~ 0xF7 => 其后为长度为L的List ，减去0xC0可得出值L（1～55）

0xF8 ~ 0xFF => 其后为长度值L（56～(2^64)-1），减去0xF7可得出L自身的长度（1~8），其后为长度为L的List

> 注意：需单独占据存储空间的长度值L（56～(2^64)-1），在去除前导0之后，采取大数端存储（big endian binary form with no leading zeroes）。

再看几个编码的例子：

"dog" => |0x83| 'd'| 'o'| 'g' |

[ "cat", "dog" ] => |0xC8|0x83|'c'|'a'|'t'|0x83|'d'|'o'|'g'|

"Lorem ipsum dolor sit amet, consectetur adipisicing elit" => |0xB8|0x38|'L'|'o'|'r'| ... |'l'|'i'|'t'|

集合论中的3，[ [ ], [ [ ] ], [ [ ], [ [ ] ] ] ] => |0xC7|0xC0|0xC1|0xC0|0xC3|0xC0|0xC1|0xC0|

机器字长32位，整数1024：|0x00|0x00|0x04|0x00| => |0x82|0x04|0x00|

机器字长32位，整数0：|0x00|0x00|0x00|0x00| => |0x80|

> 注意：整数1024被去除了高字节的前导零，整数0被去除了所有的前导零。这里的整数的编码方式，取决于我们想如何解读整数，若我们想将0表示为4字节0x00，其编码结果应当为：
|0x00|0x00|0x00|0x00| => |0x84|0x00|0x00|0x00|0x00|

RLP只针对Bytes和List进行编码和解码，但并不知道Bytes自身代表的是什么类型的数据，Bytes自身的含义，需要通过更上层的协议进行解读。
若从更广义的角度进行思考，我认为RLP不仅仅是一种编码方式，RLP更像是一门函数式编程语言，RLP编码则是二进制版本的Lisp程序源代码。

### 练习实践：

```python
## python3/pip3环境

pip install rlp==0.6.0

import rlp

list123 = [ [ ], [ [ ] ], [ [ ], [ [ ] ] ] ]

rlp.encode(list123)  ## b'\xc7\xc0\xc1\xc0\xc3\xc0\xc1\xc0'

rlp.encode( [ "cat", "dog" ] ) ## b'\xc8\x83cat\x83dog'
```

